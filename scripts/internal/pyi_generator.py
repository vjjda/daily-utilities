import sys
import argparse
import logging
import ast
import re
import os
from pathlib import Path
from typing import List, Set, Tuple, Optional, Dict, Any, Union

import typer

# Add PROJECT_ROOT to sys.path
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
sys.path.append(str(PROJECT_ROOT))

# Import utilities
try:
    from utils.logging_config import setup_logging, log_success
    from utils.core import parse_gitignore, get_submodule_paths, is_path_matched
    # Cần import DEFAULT_IGNORE từ một file config (dùng path_checker làm nguồn chung)
    from modules.path_checker.path_checker_config import DEFAULT_IGNORE
except ImportError as e:
    print(f"Error: Could not import project utilities: {e}", file=sys.stderr)
    sys.exit(1)

# --- CONSTANTS ---
IGNORED_DIRS: Set[str] = {".git", ".venv", "venv", "node_modules", "__pycache__"}
TYPE_HINT_MAP: Dict[str, str] = { # Dùng để chuyển đổi Python type sang .pyi type
    "str": "str", "int": "int", "bool": "bool", "Path": "Path",
    "List": "List", "Set": "Set", "Dict": "Dict"
}


# --- AST UTILITIES ---

def _get_ast_tree(path: Path) -> Optional[ast.Module]:
    """Reads a file and returns its AST."""
    try:
        content = path.read_bytes()
        # Đảm bảo sử dụng encoding chính xác (fallback là utf-8)
        encoding = 'utf-8' 
        return ast.parse(content.decode(encoding))
    except (UnicodeDecodeError, FileNotFoundError, SyntaxError, OSError): 
        return None

def _extract_module_list(init_path: Path, list_name: str = 'modules_to_export') -> List[str]:
    """Extracts the list of submodules from an __init__.py file using AST."""
    tree = _get_ast_tree(init_path)
    if not tree:
        return []

    for node in ast.walk(tree):
        if (isinstance(node, ast.Assign) and 
            len(node.targets) == 1 and 
            isinstance(node.targets[0], ast.Name) and 
            node.targets[0].id == list_name and
            isinstance(node.value, ast.List)):
            
            module_names: List[str] = []
            for element in node.value.elts:
                if isinstance(element, ast.Constant) and isinstance(element.value, str):
                    module_names.append(element.value)
            return module_names
    return []

def _extract_all_symbols(module_path: Path) -> Set[str]:
    """Extracts symbols from the __all__ list of a submodule."""
    tree = _get_ast_tree(module_path)
    if not tree:
        return set()

    for node in ast.walk(tree):
        if (isinstance(node, ast.Assign) and 
            len(node.targets) == 1 and 
            isinstance(node.targets[0], ast.Name) and 
            node.targets[0].id == '__all__' and
            isinstance(node.value, ast.List)):
            
            symbols: Set[str] = set()
            for element in node.value.elts:
                if isinstance(element, ast.Constant) and isinstance(element.value, str):
                    symbols.add(element.value)
            return symbols
    return set()

# --- STUB GENERATION ---

def generate_stub_content(
    init_path: Path, 
    project_root: Path
) -> Tuple[str, Set[str]]:
    """Generates the content for the .pyi file."""
    
    # 1. Get the list of submodules to process
    submodule_stems = _extract_module_list(init_path)
    
    if not submodule_stems:
        # Heuristic cho utils/core/__init__.py (chỉ định nghĩa hàm bằng tên file)
        parent_dir = init_path.parent
        submodule_stems = [
            f.stem for f in parent_dir.iterdir() 
            if f.is_file() and f.suffix == '.py' and f.name != '__init__.py'
        ]
        
    if not submodule_stems:
        return "", set()

    # 2. Collect all exported symbols from all submodules
    all_exported_symbols: Set[str] = set()
    for stem in submodule_stems:
        submodule_path = init_path.parent / f"{stem}.py"
        if submodule_path.is_file():
            symbols = _extract_all_symbols(submodule_path)
            all_exported_symbols.update(symbols)

    if not all_exported_symbols:
        return "", set()

    # 3. Build the .pyi content
    stub_lines: List[str] = []
    
    # Header
    rel_path = init_path.relative_to(project_root).as_posix()
    stub_lines.append(f"# Path: {rel_path}i (Auto-generated by pyi_generator.py)")
    stub_lines.append(f"\"\"\"Statically declared API for {init_path.parent.name}\"\"\"")
    stub_lines.append("")
    stub_lines.append("from typing import Any, List, Optional, Set, Dict, Union")
    stub_lines.append("from pathlib import Path")
    stub_lines.append("")

    # Declarations (sorted alphabetically)
    for symbol in sorted(list(all_exported_symbols)):
        # Khai báo tất cả symbol là Any (phương pháp an toàn nhất)
        stub_lines.append(f"{symbol}: Any")

    # __all__ declaration
    stub_lines.append("")
    stub_lines.append("# Static declaration of exported symbols (for Pylance)")
    # Sử dụng repr để đảm bảo chuỗi list là hợp lệ
    stub_lines.append(f"__all__: List[str] = {sorted(list(all_exported_symbols))!r}")

    return "\n".join(stub_lines), all_exported_symbols

# --- MAIN ORCHESTRATOR ---

def find_gateway_files(
    logger: logging.Logger, 
    project_root: Path
) -> List[Path]:
    """Finds all relevant __init__.py files, respecting ignore rules."""
    
    search_roots = [
        project_root / "modules", 
        project_root / "utils" / "core",
        # Thêm thư mục bootstrap vì nó cũng là dynamic gateway
        project_root / "scripts" / "internal" / "bootstrap"
    ]
    
    gitignore_spec = parse_gitignore(project_root)
    submodule_paths = get_submodule_paths(project_root)
    # Kết hợp DEFAULT_IGNORE từ config và IGNORED_DIRS cục bộ
    fnmatch_patterns = DEFAULT_IGNORE.union(IGNORED_DIRS)

    gateway_files: List[Path] = []
    for root in search_roots:
        if not root.is_dir():
            continue
            
        for path in root.rglob('__init__.py'):
            
            # 1. Check if directory/file is ignored by fnmatch
            rel_path_to_root = path.relative_to(project_root).as_posix()
            is_ignored_by_fnmatch = is_path_matched(path.parent, fnmatch_patterns, project_root) or \
                                    is_path_matched(path, fnmatch_patterns, project_root)
            if is_ignored_by_fnmatch:
                logger.debug(f"Skipping file (fnmatch ignore): {rel_path_to_root}")
                continue

            # 2. Check if in submodule
            is_in_submodule = any(path.is_relative_to(p) for p in submodule_paths)
            if is_in_submodule:
                logger.debug(f"Skipping file (submodule): {rel_path_to_root}")
                continue

            # 3. Check .gitignore
            if gitignore_spec:
                try:
                    if gitignore_spec.match_file(rel_path_to_root):
                        logger.debug(f"Skipping file (.gitignore): {rel_path_to_root}")
                        continue
                except ValueError:
                    pass

            # 4. Filter: Only process files that use the re-export logic
            try:
                content = path.read_text(encoding='utf-8')
                if "import_module" in content and "globals()[name]" in content:
                    gateway_files.append(path)
            except Exception:
                pass
                
    return gateway_files

def main(
    project_root_arg: Optional[Path] = typer.Argument(
        None, 
        help="Project root path (default: auto-detected as parent of scripts/internal).",
        exists=True, file_okay=False, dir_okay=True
    ),
    force: bool = typer.Option(
        False, "-f", "--force", 
        help="Overwrite existing .pyi files."
    ),
):
    """
    Automatically generates .pyi stub files for dynamic module gateways 
    (__init__.py) to satisfy static analysis tools like Pylance/Pyright.
    """
    
    logger = setup_logging(script_name="StubGen")
    logger.debug("Stub Generator started.")

    # 1. Determine Project Root
    if project_root_arg:
        root = project_root_arg.resolve()
    else:
        root = PROJECT_ROOT
    logger.info(f"Using project root: {root.as_posix()}")

    # 2. Find all gateway files
    gateway_files = find_gateway_files(logger, root)
    if not gateway_files:
        logger.warning("No module gateway (__init__.py) files found to process.")
        return

    # 3. Process and write stubs
    written_count = 0
    for init_file in gateway_files:
        stub_path = init_file.with_suffix(".pyi")
        
        # Safety check
        if stub_path.exists() and not force:
            logger.warning(f"⚠️ Skipping existing stub (use -f to overwrite): {stub_path.name}")
            continue

        stub_content, exported_symbols = generate_stub_content(init_file, root)
        
        if not exported_symbols:
            logger.warning(f"Skipping {init_file.name}: No exported symbols found.")
            continue
            
        try:
            stub_path.write_text(stub_content, encoding='utf-8')
            log_success(logger, f"Generated stub for: {init_file.relative_to(root).as_posix()}i")
            written_count += 1
        except IOError as e:
            logger.error(f"❌ Failed to write stub file {stub_path.name}: {e}")

    log_success(logger, f"\n✨ Stub generation complete. Successfully created/updated {written_count} stub files.")


if __name__ == "__main__":
    try:
        typer.run(main)
    except KeyboardInterrupt:
        print("\n\n❌ [Stop Command] Stub generator stopped."); sys.exit(1)